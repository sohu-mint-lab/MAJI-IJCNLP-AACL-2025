# modelsv3.py
from pydantic import BaseModel, Field, ConfigDict, model_validator
from typing import List, Optional, Any

# --- Copied from models.py ---
class ConversationTurn(BaseModel):
    model_config = ConfigDict(extra='forbid')
    speaker: str
    text: str

class OutlineItem(BaseModel):
    model_config = ConfigDict(extra='forbid')
    id: str
    question: str
    importance: str
    depth: int = Field(1, description="Depth level of the question: 1=surface, 2=detailed, 3=deep")
    keywords: List[str] = Field(default_factory=list, description="Keywords associated with the question.")
    embedding: Optional[List[float]] = Field(None, description="Vector embedding for semantic matching")

class OutlineSection(BaseModel):
    model_config = ConfigDict(extra='forbid')
    id: str
    section: str
    questions: List[OutlineItem]

class Persona(BaseModel):
    model_config = ConfigDict(extra='allow')
    name: str
    age: int
    personality: str

def flatten_outline_sections(sections: List[OutlineSection]) -> List[OutlineItem]:
    all_questions = []
    for section in sections:
        all_questions.extend(section.questions)
    return all_questions

def load_outline_from_sections(file_path: str) -> List[OutlineSection]:
    import json
    with open(file_path, "r", encoding="utf-8") as file:
        data = json.load(file)
    return [OutlineSection(**section) for section in data]

# --- New Models for V2 ---

class BackgroundSummary(BaseModel):
    model_config = ConfigDict(extra='forbid')
    long_term_summary: str = Field(..., description="Summary of long-term important information, about 150 words.")
    short_term_summary: str = Field(..., description="Summary of recent conversation turns, about 50 words.")
    
    @property
    def full_summary(self) -> str:
        return f"{self.long_term_summary}\n\n{self.short_term_summary}"

class KeywordsOutput(BaseModel):
    model_config = ConfigDict(extra='forbid')
    keywords: List[str] = Field(..., description="List of important keywords from the conversation.")

class OutlineMatch(BaseModel):
    model_config = ConfigDict(extra='forbid')
    matched_question_id: Optional[str] = Field(None, description="ID of the best matching outline question")
    matched_section_id: Optional[str] = Field(None, description="ID of the section containing the matched question")
    match_confidence: float = Field(0.0, ge=0.0, le=1.0, description="Confidence in the outline match")
    coverage_assessment: float = Field(0.0, ge=0.0, le=1.0, description="How well the response covers the matched question")

class DivergentQuestion(BaseModel):
    model_config = ConfigDict(extra='forbid')
    question: str = Field(..., description="A potential question to ask next.")
    reasoning: str = Field(..., description="The reasoning behind suggesting this question.")
    source_agent_name: str = Field(..., description="The name of the divergent agent that generated this question.")

class DivergentAgentOutput(BaseModel):
    model_config = ConfigDict(extra='forbid')
    questions: List[DivergentQuestion] = Field(..., min_length=1, description="List of important questions to ask, generated by a divergent agent.")
    source_agent_name: Optional[str] = None # Allow it to be at the top level

    @model_validator(mode='before')
    def distribute_source_agent_name(cls, data: Any) -> Any:
        if isinstance(data, dict):
            # If source_agent_name is at the top level, inject it into each question
            if 'source_agent_name' in data and 'questions' in data:
                source_name = data.get('source_agent_name')
                for question_data in data['questions']:
                    if isinstance(question_data, dict) and 'source_agent_name' not in question_data:
                        question_data['source_agent_name'] = source_name
        return data

class ConvergentAgentOutput(BaseModel):
    model_config = ConfigDict(extra='forbid')
    next_question: str = Field(..., description="The single best question to ask next.")
    reasoning: str = Field(..., description="The editor-in-chief's reasoning for selecting this question.")
    strategy: str = Field(..., description="The overall strategy employed for this decision (e.g., 'deepen_emotion', 'expand_outline', 'follow_persona').")
    chosen_divergent_question: DivergentQuestion = Field(..., description="The divergent question that was selected as the winner.")

class DivergentAgentSpec(BaseModel):
    name: str = Field(description="The name for this divergent agent, e.g., 'Causal_Thinker'.")
    instructions: str = Field(description="The detailed instructions for this agent to follow.")

class DivergentAgentPlan(BaseModel):
    agents: List[DivergentAgentSpec] = Field(description="A list of divergent agent specifications to be created.") 